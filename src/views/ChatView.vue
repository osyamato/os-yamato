<template>
  <div class="view-wrapper" @click="handleOuterClick">
    <div class="chat-container">
      <!-- üï∏Ô∏è „Éò„ÉÉ„ÉÄ„Éº -->
      <div class="chat-header">
        <span>{{ partnerDisplayName }}</span>
      </div>

      <!-- üó≥Ô∏è „É°„ÉÉ„Çª„Éº„Ç∏‰∏ÄË¶ß -->
      <div
        class="message-list"
        @scroll.passive="handleScrollTop"
        ref="messageListRef"
      >
        <template v-for="msg in groupedMessages" :key="msg.id">
          <div v-if="msg.isDateSeparator" class="date-separator">
            {{ msg.date }}
          </div>

          <div
            v-else
            class="message-row"
            :class="{ mine: msg.senderSub === mySub }"
            :id="`msg-${msg.id}`"
          >
            <!-- üí¨ Áõ∏Êâã„É°„ÉÉ„Çª„Éº„Ç∏ -->
            <div v-if="msg.senderSub !== mySub">
<template v-if="msg.contentType === 'image'">
  <div class="message-wrapper text-with-time">
    <div class="image-wrapper">
      <img
        v-if="msg.imageUrl"
        :src="msg.imageUrl"
        class="message-image"
        :key="msg.imageUrl"
        @click="openImageModal(msg.imageUrl, msg.imageKey)"
        @load="onImageLoad"
      />
      <div
        v-else-if="msg.imageKey"
        class="message-placeholder"
        @click="loadImageOnDemand(msg)"
      >
        üñºÔ∏è
      </div>
    </div>

    <!-- ‚è∞ „Çø„Ç§„É†„Çπ„Çø„É≥„Éó -->
    <span class="timestamp-right">{{ formatTime(msg.timestamp) }}</span>

    <!-- ‚ù§Ô∏è „É™„Ç¢„ÇØ„Ç∑„Éß„É≥ -->
    <div
      v-if="msg.reactions?.items?.length"
      :class="['reaction-display', 'left-corner']"
    >
      <span v-for="r in msg.reactions.items" :key="r.id || r.emoji">
        {{ r.emoji }}
      </span>
    </div>
  </div>
</template>

              <template v-else-if="isSingleEmoji(msg.content)">
                <div class="message-wrapper text-with-time">
                  <div class="emoji-only">{{ msg.content }}</div>
                  <span class="timestamp-right">{{ formatTime(msg.timestamp) }}</span>
                </div>
              </template>

              <template v-else>
                <div class="message-wrapper text-with-time">
                  <div
                    class="message"
                    @touchstart="startLongPress(msg.id)"
                    @touchend="cancelLongPress"
                    @mousedown="startLongPress(msg.id)"
                    @mouseup="cancelLongPress"
                    @mouseleave="cancelLongPress"
                  >
                    <div v-html="msg.content.replace(/\n/g, '<br>')"></div>
                  </div>
                  <span class="timestamp-right">{{ formatTime(msg.timestamp) }}</span>

                  <div v-if="msg.reactions?.items?.length" class="reaction-display over">
                    <span v-for="r in msg.reactions.items" :key="r.id || r.emoji">{{ r.emoji }}</span>
                  </div>
                </div>
              </template>
            </div>

            <!-- Ëá™ÂàÜ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ -->
            <template v-else>
              <span class="timestamp-side">{{ formatTime(msg.timestamp) }}</span>

              <template v-if="msg.contentType === 'image'">
                <div class="image-wrapper mine">
                  <img
                    v-if="msg.imageUrl"
                    :src="msg.imageUrl"
                    class="message-image"
                    :key="msg.imageUrl"
                    @click="openImageModal(msg.imageUrl, msg.imageKey)"
                    @load="onImageLoad"
                  />
                  <div
                    v-else-if="msg.imageKey"
                    class="message-placeholder"
                    @click="loadImageOnDemand(msg)"
                  >
                    üñºÔ∏è
                  </div>
                </div>
              </template>

              <template v-else-if="isSingleEmoji(msg.content)">
                <div class="emoji-only mine">{{ msg.content }}</div>
              </template>

              <template v-else>
                <div class="message-wrapper mine">
                  <div class="message mine">
                    <div v-html="msg.content.replace(/\n/g, '<br>')"></div>
                  </div>

                  <div
                    v-if="msg.reactions?.items?.length"
                    :class="[
                      'reaction-display',
                      msg.mine ? 'right-corner' : 'left-corner',
                      msg._animate ? 'reaction-emoji-animate' : ''
                    ]"
                  >
                    <span v-for="r in msg.reactions.items" :key="r.id || r.emoji">
                      {{ r.emoji }}
                    </span>
                  </div>
                </div>
              </template>
            </template>

            <!-- üéâ „É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Éî„ÉÉ„Ç´„Éº -->
            <div
              v-if="showReactionPickerFor === msg.id && msg.senderSub !== mySub"
              ref="reactionPickerRef"
              class="reaction-picker"
              @click.stop
            >
              <div class="emoji-list">
                <span
                  v-for="emoji in ['‚ù§Ô∏è','üòÜ','ü•∫','üòÆ','üòÇ','ü•∞','üëç']"
                  :key="emoji"
                  @click="selectReaction(emoji, msg)"
                >
                  {{ emoji }}
                </span>
              </div>
              <span class="copy-icon" @click.stop="copyToClipboard(msg.content)">üìã</span>
            </div>
          </div>
        </template>

        <div ref="bottomOfChat"></div>
      </div>

      <!-- ‚ú® „Ç®„Éï„Çß„ÇØ„Éà -->
      <ChatEffect ref="chatEffect" />

      <!-- üó≥Ô∏è ÂÖ•ÂäõÊ†è -->
      <div class="input-area">
        <button type="button" @click="openPhotoPicker" class="circle-button">üñº</button>
        <textarea
          ref="textareaRef"
          v-model="newMessage"
          :placeholder="t('chat.inputPlaceholder')"
          rows="1"
          class="message-input"
          @input="autoResize"
          @compositionstart="handleCompositionStart"
          @compositionend="handleCompositionEnd"
          @focus="handleInputFocus"
        ></textarea>
        <button
          type="button"
          class="circle-button"
          :class="{ shake: isShaking }"
          :disabled="isSendButtonDisabled"
          @mousedown.prevent="handleSendClick"
          @touchstart.prevent="handleSendClick"
        >
          ‚áß
        </button>
      </div>
    </div>

    <!-- üì∑ ÂÜôÁúü„Çª„É¨„ÇØ„Çø -->
    <PhotoPickerPanel
      v-if="showPhotoPicker && isMobile"
      @close="showPhotoPicker = false"
      @send="handlePhotoSelect"
    />
    <PhotoPickerModal
      v-else-if="showPhotoPicker"
      @close="showPhotoPicker = false"
      @send="handlePhotoSelect"
    />

    <!-- üëÅ „Éï„É´ÁîªÂÉè„Éó„É¨„Éì„É•„Éº -->
    <ImagePreviewModal
      :visible="showImageModal"
      :imageUrl="previewImageUrl"
      :imageKey="previewImageKey"
      @close="showImageModal = false"
    />
  </div>
</template>



<script setup>
import { ref, computed, onMounted, watchEffect, watch, nextTick, onBeforeUnmount } from 'vue'
import { API, graphqlOperation, Auth, Storage } from 'aws-amplify'
import { updateChatRoom, createMessage } from '@/graphql/mutations'
import { onCreateMessage } from '@/graphql/subscriptions'
import { useRoute } from 'vue-router'
import ChatEffect from '@/components/ChatEffect.vue'
import PhotoPickerModal from '@/components/PhotoPickerModal.vue'
import PhotoPickerPanel from '@/components/PhotoPickerPanel.vue'
import ImagePreviewModal from '@/components/ImagePreviewModal.vue'
import { listMessages, publicProfileByYamatoId } from '@/graphql/queries'
import { createReaction } from '@/graphql/mutations'
import { deleteReaction as deleteReactionMutation } from '@/graphql/mutations'
import { useChatEffects } from '@/composables/useChatEffects'


import { useI18n } from 'vue-i18n'
const isSubscribed = ref(false) // ‚úÖ ËøΩÂä†


const { t } = useI18n()

const userSettings = ref({})

const showImageModal = ref(false)
const previewImageUrl = ref('')
const previewImageKey = ref('')
const copiableMessageId = ref(null)

const selectedMessageId = ref(null)
const showReactionPicker = ref(false)
const reactionTargetMessage = ref(null)
const reactionPickerRef = ref(null) 

const suppressAutoScroll = ref(false)
const isRestoringScroll = ref(false)


const loadedImageCount = ref(0)
const imageCount = ref(0) 


const pendingScrollRestore = ref(null)

 
const chatEffect = ref(null)
const messageAnimationEnabled = ref(true)
const messageEffectEnabled = userSettings.value?.messageEffectEnabled ?? true

const { maybePlayEffect } = useChatEffects(chatEffect, messageAnimationEnabled)

let reactionSubscription = null

function handleLongPress(message) {
  reactionTargetMessage.value = message
  showReactionPicker.value = true
}

let pressTimer = null

function startPressTimer(callback) {
  clearTimeout(pressTimer)
  pressTimer = setTimeout(() => {
    callback()
  }, 600)
}


function clearPressTimer() {
  clearTimeout(pressTimer)
}


function isSingleEmoji(text) {
  const trimmed = text.trim()
  const emojiRegex = /^(\p{Emoji_Presentation}|\p{Extended_Pictographic})$/u
  return emojiRegex.test(trimmed)
}


function copyToClipboard(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text)
      .then(() => {
        copiableMessageId.value = null
        alert(t('common.copySuccess')) // ‚úÖ „É≠„Éº„Ç´„É©„Ç§„Ç∫
      })
      .catch(() => {
        alert(t('common.copyFailed')) // ‚ùå „É≠„Éº„Ç´„É©„Ç§„Ç∫
      })
  } else {
    alert(t('common.copyFailed'))
  }
}

async function selectReaction(emoji, msg) {
  const user = await Auth.currentAuthenticatedUser()
  const mySub = user.attributes.sub

  const existing = msg.reactions?.items?.find(r => r.reactorSub === mySub)

  if (existing && existing.emoji === emoji) {
    // üëá „É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÂâäÈô§
    await deleteReaction(existing.id)
    msg.reactions.items = msg.reactions.items.filter(r => r.id !== existing.id)
  } else {
    // üëá Âêå„Åò‰∫∫„ÅÆÂâç„ÅÆ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÂâäÈô§Ôºà‰∏äÊõ∏„ÅçÔºâ
    if (existing) {
      await deleteReaction(existing.id)
      msg.reactions.items = msg.reactions.items.filter(r => r.id !== existing.id)
    }

    // üëá Êñ∞„Åó„ÅÑ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÁôªÈå≤
    const result = await API.graphql(graphqlOperation(createReaction, {
      input: {
        messageId: msg.id,
        emoji,
        reactorSub: mySub,
        reactorYamatoId: user.attributes['custom:yamatoId'] || 'ÂåøÂêç'
      }
    }))

    const newReaction = result.data?.createReaction
    if (newReaction) {
      if (!msg.reactions) msg.reactions = { items: [] }
      msg.reactions.items.push(newReaction)

      // ‚úÖ „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áô∫ÁÅ´„ÅÆ„Åü„ÇÅ„ÅÆÂ∑•Â§´
      msg._animate = false
      await nextTick()
      msg._animate = true

      // ‚è±Ô∏è „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁµÇ‰∫Ü„Åß„É™„Çª„ÉÉ„ÉàÔºà500ms ÂæåÔºâ
      setTimeout(() => {
        msg._animate = false
      }, 500)
    }
  }

  // üëá „Éî„ÉÉ„Ç´„ÉºÈñâ„Åò„Çã
  showReactionPickerFor.value = null
}

async function reactToMessage(emoji) {
  const user = await Auth.currentAuthenticatedUser()
  await API.graphql(graphqlOperation(createReaction, {
    input: {
      messageId: props.message.id,
      emoji,
      reactorSub: user.attributes.sub,
      reactorYamatoId: user.attributes['custom:yamatoId'] || 'ÂåøÂêç'
    }
  }))
  showPicker.value = false
}

async function loadImageOnDemand(msg) {
  if (msg.imageUrl) return // „Åô„Åß„Å´ÂèñÂæóÊ∏à„Åø„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ

  try {
    const key = msg.thumbnailKey || msg.imageKey
    const url = await Storage.get(key, { level: 'public' })
    msg.imageUrl = url
  } catch (e) {
    console.warn('‚ùå ÁîªÂÉèÂÄãÂà•ÂèñÂæóÂ§±Êïó:', msg.imageKey, e)
  }
}

function subscribeToNewReactions() {
  reactionSubscription = API.graphql(graphqlOperation(onCreateReaction)).subscribe({
    next: ({ value }) => {
      const newReaction = value?.data?.onCreateReaction
      if (!newReaction?.messageId) return

      const targetMsg = messages.value.find(m => m.id === newReaction.messageId)
      if (!targetMsg) return

      // „É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÊú™ÂÆöÁæ©„Å™„ÇâÂàùÊúüÂåñ
      if (!targetMsg.reactions) {
        targetMsg.reactions = { items: [] }
      }

      // Âêå„Åò sender „Åå„Åô„Åß„Å´„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Å™„ÇâÁΩÆ„ÅçÊèõ„Åà
      const existingIndex = targetMsg.reactions.items.findIndex(
        r => r.senderSub === newReaction.senderSub
      )

      if (existingIndex !== -1) {
        targetMsg.reactions.items.splice(existingIndex, 1, newReaction)
      } else {
        targetMsg.reactions.items.push(newReaction)
      }
    },
    error: err => console.error('‚ùå „É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Ç®„É©„Éº:', err)
  })
}
function subscribeToReactions() {
  reactionSubscription = API.graphql(graphqlOperation(onCreateReaction)).subscribe({
    next: ({ value }) => {
      const newReaction = value?.data?.onCreateReaction
      if (!newReaction?.messageId) return

      // ÂØæË±°„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊé¢„Åó„Å¶ÂèçÊò†
      const msgIndex = messages.value.findIndex(m => m.id === newReaction.messageId)
      if (msgIndex !== -1) {
        const msg = messages.value[msgIndex]

        // Êó¢„Å´ reactions.items „Åå„ÅÇ„Çã„ÅãÁ¢∫Ë™ç
        if (!msg.reactions || !msg.reactions.items) {
          msg.reactions = { items: [] }
        }

        // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºàÂêå„Åò reactorSub „ÅÆÁµµÊñáÂ≠ó„ÅØ‰∏äÊõ∏„ÅçÔºâ
        const existing = msg.reactions.items.findIndex(r => r.reactorSub === newReaction.reactorSub)
        if (existing !== -1) {
          msg.reactions.items.splice(existing, 1, newReaction)
        } else {
          msg.reactions.items.push(newReaction)
        }

        // ÂÜçÊèèÁîª„ÅÆ„Åü„ÇÅ„Å´ Vue „Å´ÈÄöÁü•
        messages.value.splice(msgIndex, 1, { ...msg })
      }
    },
    error: (err) => console.error('‚ùå „É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Çµ„Éñ„Çπ„ÇØ„Ç®„É©„Éº:', err)
  })
}

const showReactionPickerFor = ref(null)
let longPressTimer = null

function startLongPress(messageId) {
  longPressTimer = setTimeout(() => {
    showReactionPickerFor.value = showReactionPickerFor.value === messageId ? null : messageId
    copiableMessageId.value = messageId // ‚úÖ „Åì„Çå„ÇíËøΩÂä†
  }, 500)
}

function cancelLongPress() {
  if (longPressTimer) {
    clearTimeout(longPressTimer)
    longPressTimer = null
  }
}


async function deleteReaction(reactionId) {
  try {
    await API.graphql(graphqlOperation(deleteReactionMutation, {
      input: { id: reactionId }
    }))
  } catch (e) {
    console.error('‚ùå „É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÂâäÈô§Â§±Êïó:', e)
  }
}

const onCreateReaction = /* GraphQL */ `
  subscription OnCreateReaction {
    onCreateReaction {
      id
      messageId
      emoji
      reactorSub
      reactorYamatoId
      createdAt
    }
  }
`

const messagesByRoomIdQuery = /* GraphQL */ `
  query MessagesByRoomId(
    $roomId: ID!
    $sortDirection: ModelSortDirection
    $limit: Int
    $nextToken: String
  ) {
    messagesByRoomId(
      roomId: $roomId
      sortDirection: $sortDirection
      limit: $limit
      nextToken: $nextToken
    ) {
      items {
        id
        roomId
        senderSub
        content
        contentType
        imageKey
        timestamp
        createdAt
        reactions {
          items {
            id
            emoji
            reactorSub
            reactorYamatoId
          }
        }
      }
      nextToken  # ‚úÖ „Åì„Çå„ÇíÂøÖ„ÅöËøΩÂä†ÔºÅ
    }
  }
`

function onImageLoad() {
  loadedImageCount.value++

  if (
    imageCount.value > 0 &&
    loadedImageCount.value >= imageCount.value &&
    pendingScrollRestore.value &&
    messageListRef.value
  ) {
    const list = messageListRef.value
    const { anchorId } = pendingScrollRestore.value
    pendingScrollRestore.value = null

    suppressAutoScroll.value = false

    nextTick(() => {
      requestAnimationFrame(() => {
        const anchorEl = document.getElementById(anchorId)
        if (anchorEl) {
          anchorEl.scrollIntoView({ block: 'start' })
        }
      })
    })
  }
}

async function openImageModal(thumbnailUrl, fullKey) {
  try {
    const fullUrl = await Storage.get(fullKey, { level: 'public' })
    previewImageUrl.value = fullUrl
    previewImageKey.value = fullKey // ‚úÖ „Åì„Çå„ÇíËøΩÂä†
  } catch (e) {
    previewImageUrl.value = thumbnailUrl
    previewImageKey.value = fullKey // ‚úÖ fallback Áî®„Å´„ÇÇ key „ÇíÊ∏°„Åô
  } finally {
    showImageModal.value = true
  }
}

const textareaRef = ref(null)
const isComposing = ref(false)
const bottomOfChat = ref(null)

const partnerDisplayName = ref('')
const messages = ref([])
const newMessage = ref('')
const myYamatoId = ref('')
const mySub = ref('')
const roomId = ref('')
const receiverYamatoId = ref('')
const receiverSub = ref('')
const showPhotoPicker = ref(false)
const isMobile = ref(false)


const isJapaneseInput = ref(false)

function handleCompositionStart(e) {
  isComposing.value = true
  isJapaneseInput.value = /[„ÅÅ-„Çì„Ç°-„É≥]/.test(e.data || '')
}

const forceUpdateTrigger = ref(0)

function handleCompositionEnd() {
  isComposing.value = false
  isJapaneseInput.value = false

  nextTick(() => {
    forceUpdateTrigger.value++  // üîÅ ÂÜçË©ï‰æ°„ÇíÊòéÁ§∫
  })
}


const route = useRoute()
let subscription = null

const groupedMessages = computed(() => groupMessagesByDate(messages.value))

onMounted(() => {
  isMobile.value = window.matchMedia('(max-width: 768px)').matches
})

function openPhotoPicker() {
  showPhotoPicker.value = true
}

async function handlePhotoSelect(photoOrPhotos) {
  const photos = Array.isArray(photoOrPhotos) ? photoOrPhotos : [photoOrPhotos]

  for (const photo of photos) {
    console.log('üì• Âèó‰ø° photo:', photo)

    // ‚úÖ „Åì„Åì„Åß previewUrl „Å® thumbPreviewUrl „ÇíÊ≠£„Åó„ÅèÊãæ„ÅÜ
    const preview = photo.previewUrl || photo.thumbPreviewUrl || ''

    if (!photo || !photo.imageKey || !photo.thumbnailKey) {
      console.warn('‚ö†Ô∏è ‰∏çÊ≠£„Å™ photo „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà:', photo)
      continue
    }

    const now = new Date()
    const tempId = `temp-${now.getTime()}`

    const tempMessage = {
      id: tempId,
      roomId: roomId.value,
      senderSub: mySub.value,
      senderYamatoId: myYamatoId.value,
      receiverSub: receiverSub.value,
      receiverYamatoId: receiverYamatoId.value,
      content: '',
      contentType: 'image',
      imageKey: photo.imageKey,
      thumbnailKey: photo.thumbnailKey,
      timestamp: now.toISOString(),
      imageUrl: preview,
      isTemporary: true,
    }

    console.log('‚úÖ ‰ªÆ„É°„ÉÉ„Çª„Éº„Ç∏ËøΩÂä†:', tempMessage)

    messages.value.push(tempMessage)

    try {
      await sendImageMessage(photo.imageKey, photo.thumbnailKey)

      const finalUrl = await tryGetUrl(photo.thumbnailKey)
      const msg = messages.value.find(m => m.id === tempId)
      if (msg && finalUrl) msg.imageUrl = finalUrl
    } catch (e) {
      console.error('‚ùå ÁîªÂÉèÈÄÅ‰ø°„Ç®„É©„Éº:', e)
    }
  }

  showPhotoPicker.value = false
}


async function sendImageMessage(imageKey, thumbnailKey) {
  const now = new Date()
  const expiresAt = Math.floor(now.getTime() / 1000) + 365 * 24 * 60 * 60

  const input = {
    roomId: roomId.value,
    senderSub: mySub.value,
    senderYamatoId: myYamatoId.value,
    receiverSub: receiverSub.value,
    receiverYamatoId: receiverYamatoId.value,
    content: '',
    contentType: 'image',
    imageKey,
    thumbnailKey,
    timestamp: now.toISOString(),
    expiresAt
  }

  try {
    await API.graphql(graphqlOperation(createMessage, { input }))

    await API.graphql(graphqlOperation(updateChatRoom, {
      input: {
        id: roomId.value,
        lastMessage: 'üì∑ Photo',
        lastContentType: 'image',
        lastSenderId: mySub.value,
        lastTimestamp: now.toISOString()
      }
    }))
  } catch (err) {
    console.error('‚ùå ÁîªÂÉè„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°„Ç®„É©„Éº:', JSON.stringify(err, null, 2))
  }
}

watchEffect(() => {
  const params = route?.params || {}
  roomId.value = params.roomId || ''
  receiverYamatoId.value = params.receiverYamatoId || ''
})


watch(groupedMessages, async () => {
  if (suppressAutoScroll.value) return
  await nextTick()
  scrollToBottom()
})


watch(messages, () => {
  const lastMsg = messages.value[messages.value.length - 1]
  if (!lastMsg || lastMsg.senderSub === mySub.value) return
  if (messageAnimationEnabled.value) {
    maybePlayEffect(lastMsg.content)
  }
})


function dismissKeyboard() {
  const activeElement = document.activeElement
  if (activeElement && typeof activeElement.blur === 'function') {
    activeElement.blur()
  }
}

function handleOuterClick(event) {
  const target = event.target

  const isClickInsideTextarea = textareaRef.value?.contains(target)
  const isClickInsidePicker = reactionPickerRef.value?.contains?.(target)

  if (isClickInsideTextarea || isClickInsidePicker) {
    return
  }

  // Â§ñÂÅ¥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„ÇâÈñâ„Åò„Çã
  showReactionPickerFor.value = null
  dismissKeyboard()
}

// ÈÄÅ‰ø°„Éú„Çø„É≥„ÅÆÊ¥ªÊÄßÂåñÊù°‰ª∂ÔºàÁ©∫ÁôΩ„ÅÆ„Åø„Å™„ÇâÈùûÊ¥ªÊÄßÔºâ
const isSendButtonDisabled = computed(() => {
  return newMessage.value.trim() === ''
})

function hideKeyboard() {
  const el = document.activeElement
  if (el && typeof el.blur === 'function') el.blur()
}


onMounted(async () => {
  // ‚úÖ 1. Ë™çË®º„É¶„Éº„Ç∂„Éº„ÅÆÂèñÂæó„Å®Âü∫Êú¨ÊÉÖÂ†±
  const user = await Auth.currentAuthenticatedUser()
  mySub.value = user.attributes.sub
  const animSetting = user.attributes['custom:message_animation']
  messageAnimationEnabled.value = animSetting !== 'off' // undefined „ÇÇ true Êâ±„ÅÑ

  // ‚úÖ 2. Ëá™ÂàÜ„ÅÆ Yamato ID „ÇíÂèñÂæó
  const profileRes = await API.graphql({
    query: /* GraphQL */ `
      query GetMyProfile($id: ID!) {
        getPublicProfile(id: $id) {
          yamatoId
        }
      }`,
    variables: { id: mySub.value },
    authMode: 'AMAZON_COGNITO_USER_POOLS'
  })

  myYamatoId.value = profileRes.data.getPublicProfile.yamatoId

  // ‚úÖ 3. Áõ∏Êâã„ÅÆ„Éó„É≠„Éï„Ç£„Éº„É´ÂèñÂæó
  const partnerRes = await API.graphql(graphqlOperation(publicProfileByYamatoId, {
    yamatoId: receiverYamatoId.value
  }))
  const partner = partnerRes.data.publicProfileByYamatoId.items[0]

  if (!partner) {
    console.warn('‚ö†Ô∏è partner „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü')
    partnerDisplayName.value = '‰∏çÊòé'
    return
  }

  receiverSub.value = partner.id
  partnerDisplayName.value = partner.displayName || 'Áõ∏Êâã'

  // ‚úÖ 4. „É°„ÉÉ„Çª„Éº„Ç∏ÂèñÂæó„Å®„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÁôªÈå≤ÔºàfetchMessages ÂÜÖ„Åß subscribe Âëº„Å∂Ôºâ
  await fetchMessages()

  // ‚úÖ 5. ÂàùÊúü„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆË™øÊï¥ÔºàÁîªÂÉè„Å™„Åó„Å™„ÇâÂç≥„Çπ„ÇØ„É≠„Éº„É´Ôºâ
  loadedImageCount.value = 0
  await nextTick()
  if (imageCount.value === 0) {
    scrollToBottom(true)
  }
})

onBeforeUnmount(() => {
  if (subscription) subscription.unsubscribe()
  if (reactionSubscription) reactionSubscription.unsubscribe()
})

const isShaking = ref(false)

const isSending = ref(false)

function handleSendClick(event) {
  if (!isSubscribed.value) {
    console.warn('üïì „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅåÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅÈÄÅ‰ø°„ÇíÂæÖÊ©ü„Åó„Åæ„Åô')
    return
  }

  if (isSending.value) return // üõë „Åô„Åß„Å´ÈÄÅ‰ø°‰∏≠„Å™„ÇâÁÑ°Ë¶ñ

  // ‚úÖ Â§âÊèõ‰∏≠„Åæ„Åü„ÅØÁõ¥Âæå„ÅßÊú™Á¢∫ÂÆöÊñáÂ≠ó„ÅÆÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Å®„Åç„ÅØÈÄÅ‰ø°„Åï„Åõ„Å™„ÅÑ
  if (isComposing.value || isJapaneseInput.value) {
    event?.preventDefault()
    event?.stopPropagation()

    isShaking.value = true
    setTimeout(() => {
      isShaking.value = false
    }, 300)

    setTimeout(() => {
      textareaRef.value?.focus()
    }, 0)
    return
  }

  if (!newMessage.value.trim()) {
    isShaking.value = true
    setTimeout(() => {
      isShaking.value = false
    }, 300)
    return
  }

  isComposing.value = false
  isJapaneseInput.value = false

  // üö´ „Åì„Åì„ÅßÈÄ£ÊâìÈò≤Ê≠¢„Éï„É©„Ç∞ON
  isSending.value = true

  // üöÄ ÂÆüÈöõ„ÅÆÈÄÅ‰ø°Âá¶ÁêÜ
  sendMessage()
    .then(() => {
      newMessage.value = ''
    })
    .finally(() => {
      isSending.value = false
    })
}


async function sendMessage() {
  if (isComposing.value) return

  const content = (newMessage.value || '').trim()
  if (!content) return

  const now = new Date()
  const expiresAt = Math.floor(now.getTime() / 1000) + 365 * 24 * 60 * 60

  const input = {
    roomId: roomId.value,
    senderSub: mySub.value,
    senderYamatoId: myYamatoId.value,
    receiverSub: receiverSub.value,
    receiverYamatoId: receiverYamatoId.value,
    content,
    timestamp: now.toISOString(),
    expiresAt
  }

  try {
    // ‚úÖ „É°„ÉÉ„Çª„Éº„Ç∏‰ΩúÊàê
    await API.graphql(graphqlOperation(createMessage, { input }))

    // ‚úÖ „ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†Êõ¥Êñ∞
    await API.graphql(graphqlOperation(updateChatRoom, {
      input: {
        id: roomId.value,
        lastMessage: content,
        lastContentType: 'text',
        lastTimestamp: now.toISOString(),
        lastSenderId: mySub.value,
        expiresAt
      }
    }))

    // ‚úÖ ÊàêÂäüÂæåÂá¶ÁêÜ
    newMessage.value = ''
    await nextTick()

    if (textareaRef.value) {
      textareaRef.value.style.height = 'auto'
    }

    const triggered = maybePlayEffect(content)
    if (!triggered && textareaRef.value) {
      textareaRef.value.focus()
    }
  } catch (err) {
    // ‚úÖ Ë©≥Á¥∞„Å™„Ç®„É©„Éº„É≠„Ç∞Âá∫Âäõ
    console.error('‚ùå „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°„Ç®„É©„Éº:', err)

    if (err.errors && Array.isArray(err.errors)) {
      err.errors.forEach(e => {
        console.error('GraphQL Error:', e.message || e)
      })
    } else if (err.message) {
      console.error('Error message:', err.message)
    } else {
      console.error('Unknown error:', JSON.stringify(err, null, 2))
    }

    // UI„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Å™„Å©„ÇíËøΩÂä†„Åô„Çã„Å™„Çâ„Åì„Åì
  }
}

function autoResize(event) {
  const textarea = event.target
  textarea.style.height = 'auto'
  textarea.style.height = Math.min(textarea.scrollHeight, 150) + 'px'
}

function formatTime(ts) {
  const date = new Date(ts)
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
}


async function fetchMessages() {
  try {
    if (subscription) {
      subscription.unsubscribe()
      subscription = null
    }

    const res = await API.graphql(graphqlOperation(messagesByRoomIdQuery, {
      roomId: roomId.value,
      sortDirection: "DESC",
      limit: 30
    }))

    const items = res.data.messagesByRoomId.items || []
    nextToken = res.data.messagesByRoomId.nextToken

    const sorted = items
      .filter(msg => !!msg)
      .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))

    // ‚úÖ STEP 1: „Åæ„Åö„ÅØ imageUrl: null „Åß‰ª£ÂÖ•
    messages.value = sorted.map(msg => ({
      ...msg,
      imageUrl: null
    }))

    await nextTick()
    scrollToBottom()

    // ‚úÖ STEP 2: ÈÅÖÂª∂„Åó„Å¶ÁîªÂÉè„ÇíÂèñÂæó„ÉªÂ∑Æ„ÅóÊõø„Åà„Çã
    setTimeout(() => {
      loadImageUrls(messages.value)
    }, 500) // 500ms „Åª„Å©ÈÅÖ„Çâ„Åõ„Çã„ÅÆ„ÅåËá™ÁÑ∂„Åß„Åô

    subscribeToNewMessages()
  } catch (err) {
    console.error('‚ùå „É°„ÉÉ„Çª„Éº„Ç∏ÂèñÂæó„Ç®„É©„Éº:', JSON.stringify(err, null, 2))
  }
}

async function loadImageUrls(messageList) {
  const now = new Date()

  for (let msg of messageList) {
    if (msg.contentType === 'image' && msg.imageKey && msg.imageUrl === null) {
      const msgDate = new Date(msg.timestamp)
      const daysDiff = (now - msgDate) / (1000 * 60 * 60 * 24)

      if (daysDiff <= 14) {
        try {
          const thumbKey = msg.thumbnailKey || msg.imageKey
          const url = await Storage.get(thumbKey, { level: 'public' })
          msg.imageUrl = url
        } catch {
          msg.imageUrl = null
        }
      }
    }
  }

  // Vue „ÅÆÂÜçÊèèÁîª„Çí‰øÉ„ÅôÔºàÂøÖÈ†àÔºâ
  messages.value = [...messageList]
}

let nextToken = null
const messageIds = new Set()

async function fetchMoreMessages() {
  try {
    if (!nextToken || !messageListRef.value) return

    suppressAutoScroll.value = true
    const list = messageListRef.value

    console.log('üîÑ ÈÅéÂéª„É°„ÉÉ„Çª„Éº„Ç∏ÂèñÂæó nextToken:', nextToken)

    // ÂèñÂæóÂâç„ÅÆ„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„Çí‰øùÂ≠ò
    const prevScrollTop = list.scrollTop
    const prevScrollHeight = list.scrollHeight

    const res = await API.graphql(graphqlOperation(messagesByRoomIdQuery, {
      roomId: roomId.value,
      sortDirection: "DESC",
      limit: 30,
      nextToken
    }))

    const newItems = res.data.messagesByRoomId.items || []
    nextToken = res.data.messagesByRoomId.nextToken

    const sorted = newItems
      .filter(msg => !!msg && !messageIds.has(msg.id))
      .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))

    const enriched = sorted.map(msg => {
      messageIds.add(msg.id)
      if (msg.contentType === 'image' && msg.imageKey) {
        return { ...msg, imageUrl: null }
      }
      return msg
    })

    if (enriched.length === 0) {
      suppressAutoScroll.value = false
      return
    }

    // üîº Âè§„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâçÊñπ„Å´ËøΩÂä†
    messages.value = [...enriched, ...messages.value]

    await nextTick()

    // ‚úÖ Â∑ÆÂàÜ„Çπ„ÇØ„É≠„Éº„É´Ôºö„Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„ÇíÁ∂≠ÊåÅ„Åô„Çã„Åü„ÇÅ„Å´„Åö„Çâ„Åô
    const newScrollHeight = list.scrollHeight
    const diff = newScrollHeight - prevScrollHeight
    list.scrollTop = prevScrollTop + diff

    suppressAutoScroll.value = false
  } catch (err) {
    console.error('‚ùå fetchMoreMessages „Ç®„É©„Éº:', JSON.stringify(err, null, 2))
    suppressAutoScroll.value = false
  }
}

‚Ä®


const messageListRef = ref(null)

function handleScrollTop() {
  const el = messageListRef.value
  if (el && el.scrollTop === 0) {
    fetchMoreMessages()
  }
}

function subscribeToNewMessages() {
  subscription = API.graphql(graphqlOperation(onCreateMessage)).subscribe({
    next: async ({ value }) => {
      const newMsg = value?.data?.onCreateMessage
      if (!newMsg?.roomId) return

      if (newMsg.roomId === roomId.value) {
        let enrichedMsg = newMsg

        // üí¨ ÁîªÂÉè„ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ...
        if (newMsg.contentType === 'image' && newMsg.imageKey) {
          try {
            const url = await Storage.get(newMsg.thumbnailKey || newMsg.imageKey, {
              level: 'public'
            })
            enrichedMsg = { ...newMsg, imageUrl: url }
          } catch (e) {
            console.warn('‚ö†Ô∏è „Çµ„Éñ„Çπ„ÇØ‰∏≠„ÅÆÁîªÂÉèÂèñÂæó„Ç®„É©„Éº:', e)
          }
        }

        // ‚úÖ ‰ªÆ„É°„ÉÉ„Çª„Éº„Ç∏ÁΩÆÊèõ„Åæ„Åü„ÅØËøΩÂä†
        const existingIndex = messages.value.findIndex(
          m => m.imageKey === newMsg.imageKey && m.isTemporary
        )

        if (existingIndex !== -1) {
          messages.value.splice(existingIndex, 1, enrichedMsg)
          messages.value = [...messages.value] // ‚úÖ ÊòéÁ§∫ÁöÑ„Å´ÂÜçÊèèÁîª„Çí‰øÉ„Åô
        } else {
          const exists = messages.value.findIndex(m => m.id === newMsg.id) !== -1
          if (!exists) {
            messages.value = [...messages.value, enrichedMsg] // ‚úÖ push „ÅÆ‰ª£„Çè„Çä„Å´Êñ∞„Ç§„É≥„Çπ„Çø„É≥„Çπ
          }
        }

        if (enrichedMsg.senderSub !== mySub.value && messageAnimationEnabled.value) {
          maybePlayEffect(enrichedMsg.content)
        }

        await nextTick()
        setTimeout(() => scrollToBottom(), 0)
      }
    },
    error: (err) => console.error('‚ùå „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Ç®„É©„Éº:', err)
  })

  isSubscribed.value = true // ‚úÖ ÊúÄÂæå„Å´ÂÆå‰∫Ü„ÇíÊòéÁ§∫
}


function groupMessagesByDate(messages) {
  const grouped = []
  let lastDate = null
  for (const msg of messages) {
    const date = new Date(msg.timestamp).toLocaleDateString('ja-JP', {
      year: 'numeric', month: 'long', day: 'numeric', weekday: 'short'
    })
    if (date !== lastDate) {
      grouped.push({ isDateSeparator: true, date })
      lastDate = date
    }
    grouped.push(msg)
  }
  return grouped
}

function scrollToBottom(immediate = false) {
  if (suppressAutoScroll.value) {
    console.log('üö´ scrollToBottom suppressed')
    suppressAutoScroll.value = false
    return
  }

  bottomOfChat.value?.scrollIntoView({ behavior: immediate ? 'auto' : 'smooth' })
}

function shouldTriggerEffect(content, season) {
  const pattern = new RegExp(`${season}(?![‰∏Ä-ÈæØ])`)
  return pattern.test(content)
}


async function tryGetUrl(key, retries = 5, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try {
      const url = await Storage.get(key, { level: 'public' })
      return url
    } catch (e) {
      console.warn(`üïì retry ${i + 1} for key: ${key}`, e)
      await new Promise(res => setTimeout(res, delay))
    }
  }
  console.error('‚ùå Storage.get Â§±Êïó:', key)
  return null
}

function handleInputFocus() {
  if (!isMobile.value) return

  // „ÇΩ„Éï„Éà„Ç≠„Éº„Éú„Éº„ÉâË°®Á§∫Áõ¥Âæå„Å´„Çπ„ÇØ„É≠„Éº„É´
  setTimeout(() => {
    scrollToBottom(true) // Âç≥Â∫ß„Å´„Ç∏„É£„É≥„Éó
  }, 300) // „É¢„Éê„Ç§„É´„Åß„ÅÆ keyboard Èñã„Åè„Çø„Ç§„Éü„É≥„Ç∞„Å´Âêà„Çè„Åõ„Å¶ÂæÆË™øÊï¥
}

</script>

‚Ä®



<style scoped>

.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: #ffffff;
  color: #000;
  box-sizing: border-box;

  width: 100%;
  margin: 0 auto;
  max-width: 600px; /* ‚úÖ PCÂêë„ÅëÊúÄÂ§ßÂπÖ */
}

/* ‚úÖ PCÂêë„Åë„Å´min-width„ÇíËøΩÂä† */
@media (min-width: 768px) {
  .chat-container {
    min-width: 600px;
  }
}


button.disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.message-list {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  padding: 1rem;
}

/* Âêπ„ÅçÂá∫„Åó + ÊôÇÈñì„ÅÆ1„Çª„ÉÉ„ÉàÔºàÊ®™‰∏¶„Å≥Ôºâ */
.message-row {
  display: flex;
  justify-content: flex-start; /* Áõ∏ÊâãÔºöÂ∑¶ÂØÑ„Åõ */
  align-items: flex-end;
  margin: 0.5rem 0;
  position: relative; 
}

.message-row.mine {
  justify-content: flex-end; /* Ëá™ÂàÜÔºöÂè≥ÂØÑ„Åõ */
}

/* Âêπ„ÅçÂá∫„ÅóÊú¨‰Ωì */


/* Âêπ„ÅçÂá∫„ÅóÊ®™„ÅÆÊôÇÈñì */
.timestamp-side {
  font-size: 0.75rem;
  color: #aaa;
  margin: 0 0.5rem;
  white-space: nowrap;
  align-self: center;
}

.text-with-time {
  display: flex;
  align-items: flex-end;
  gap: 0.4rem;
}

.timestamp-right {
  font-size: 0.75rem;
  color: #aaa;
  margin-left: 0.6rem; /* ‚Üê ÊôÇË®à„Å®„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂπ≤Ê∏âÈò≤Ê≠¢ */
  white-space: nowrap;
  align-self: flex-end;
}

.image-wrapper.text-with-time {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.3rem;
}

/* Êó•‰ªò„Çª„Éë„É¨„Éº„Çø */
.date-separator {
  text-align: center;
  margin: 1rem 0 0.5rem;
  font-size: 0.8rem;
  color: #bbb;
}

/* ÂÖ•ÂäõÊ¨Ñ */
.input-area {
  display: flex;
  align-items: flex-end; /* ‚úÖ „Éú„Çø„É≥„Çí‰∏ãÁ´Ø„Å´„Åù„Çç„Åà„Çã */
  padding: 1rem;
  border-top: 1px solid #333;
  gap: 0.5rem;
}

.modal-title {
  color: #111; /* ‚Üê „É©„Ç§„Éà„É¢„Éº„ÉâÁî®„ÅÆÈªíÊñáÂ≠ó */
  font-size: 1.2rem;
  margin-bottom: 1rem;
  text-align: center;
}

.message-input {
  flex: 1;
  padding: 0.6rem 1rem;
  font-size: 1rem;
  border-radius: 18px;
  border: 1px solid #ccc;
  background-color: #fff; /* ÈÄöÂ∏∏„É¢„Éº„Éâ„Åß„ÅØÁôΩ */
  color: #000;
  overflow-y: auto;
  resize: none;
  max-height: 150px;
  min-height: 40px;
  transition: height 0.1s ease-out;
  box-sizing: border-box;
}

.view-wrapper {
  height: 100vh;
  display: flex;
  flex-direction: column;
}
.chat-header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: rgba(255, 255, 255, 0.5); /* ‚Üê üå∏ ÈÄèÈÅéÁéá„Ç¢„ÉÉ„Éó */
  backdrop-filter: blur(10px);          /* ‚Üê „Åº„Åã„ÅóÂäπÊûúÂº∑„ÇÅ */
  padding: 0.75rem 1rem;
  font-size: 1.1rem;
  font-weight: bold;
  text-align: center;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* „ÇΩ„Éï„Éà„Å™Â¢ÉÁïåÁ∑ö */
  color: #333;
}


/* „ÉÄ„Éº„ÇØ„É¢„Éº„Éâ */
/* üëá scoped„Çπ„Çø„Ç§„É´ÂÜÖ„Åß„ÇÇ„Åó„Å£„Åã„ÇäÈÅ©Áî®„Åï„Çå„Çã„Çà„ÅÜ„Å´ :deep() „Çí‰Ωø„ÅÜ */
/* üí° Êó¢Â≠ò„ÅÆ .chat-container „Å´ÂØæ„Åô„Çã„ÉÄ„Éº„ÇØ„É¢„Éº„Éâ„ÅÆÊåáÂÆö„Åå‰∏çÂÆåÂÖ® */
@media (prefers-color-scheme: dark) {
  .chat-container {
    background-color: #121212 !important; /* Âº∑Âà∂ÁöÑ„Å´ÈÅ©Áî®„Åï„Åõ„Çã */
    color: #fff !important;
  }

  .message {
    background-color: #333 !important;
    color: #fff !important;
  }

  .message.mine {
    background-color: #274c77 !important; /* Ëá™ÂàÜ„ÅÆÂêπ„ÅçÂá∫„Åó„ÅÆËâ≤„ÅØÂ§â„Åà„Å™„ÅÑ */
  }

  .chat-header {
    background: rgba(0, 0, 0, 0.4) !important;
    color: #fff !important;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
  }

}


.message-row.mine {
  justify-content: flex-end;
  /* text-align: right; ‚Üê ‚≠êÔ∏è „Åì„Çå„ÇíÂâäÈô§„Åô„Çã */
}

.message {
  display: inline-block;
  padding: 0.75rem 1rem;
  border-radius: 18px;
  font-size: 1rem;
  background-color: #e0e0e0;
  color: #000;
  word-break: break-word;
  white-space: pre-wrap;
  line-height: 1.5;
  text-align: left;
  max-width: min(80vw, 520px);
}

/* üë§ Áõ∏Êâã„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ ‚Üí ÈÅ∏Êäû‰∏çÂèØ */
.message:not(.mine) {
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-touch-callout: none;
}

.message.mine {
  user-select: text;
  -webkit-user-select: text;

  background-color: #274c77;
  color: #fff;
  margin-left: auto; /* üí° Ëá™ÂàÜ„ÅÆÂêπ„ÅçÂá∫„Åó„ÅØÂè≥„Å´ÂØÑ„Åõ„Çã */
}

/* ‚úÖ „Çπ„Éû„Éõ„ÅØ„ÇÑ„ÇÑÁã≠„ÇÅÔºà70vwÔºâ */
@media (max-width: 600px) {
  .message {
    max-width: 70vw;
  }
}

button {
  flex-shrink: 0;
  height: 40px;           /* ‚úÖ „ÉÜ„Ç≠„Çπ„ÉàÊ¨Ñ„Å®ÊèÉ„Åà„Çã */
  padding: 0 1rem;
  font-size: 1rem;
  background-color: #274c77;
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  transition: opacity 0.2s;
  align-self: flex-end;
}

button:hover {
  opacity: 0.9;
}


.circle-button {
  background-color: #274c77;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 2.4rem !important;
  height: 2.4rem !important;
  font-size: 1.2rem;
  display: inline-flex;         /* üí° PCÊôÇ„ÅÆÊã°Âºµ„ÇíÊäëÂà∂ */
  align-items: center;
  justify-content: center;
  margin-left: 0.4rem;
  cursor: pointer;
  flex: 0 0 auto;               /* üí° ÂÆåÂÖ®Âõ∫ÂÆö„Å´„Åô„Çã */
  transition: background-color 0.2s ease;
}

.circle-button:disabled {
  background-color: #274c77;  /* ÈÄöÂ∏∏„Å®Âêå„ÅòËâ≤ */
  color: white;
  opacity: 1;                 /* ÂçäÈÄèÊòé„ÇíÈò≤Ê≠¢ */
  cursor: default;            /* or keep as 'pointer' */
}


@keyframes shake {
  0% { transform: translateX(0); }
  10% { transform: translateX(-4px); }
  20% { transform: translateX(4px); }
  30% { transform: translateX(-4px); }
  40% { transform: translateX(4px); }
  50% { transform: translateX(-3px); }
  60% { transform: translateX(3px); }
  70% { transform: translateX(-2px); }
  80% { transform: translateX(2px); }
  90% { transform: translateX(-1px); }
  100% { transform: translateX(0); }
}

.shake {
  animation: shake 0.6s ease;
}

.circle-button:disabled {
  background-color: #274c77 !important;
  color: white !important;
  opacity: 1 !important;
  cursor: default !important;
}

.circle-button:disabled:hover {
  background-color: #274c77 !important;
  color: white !important;
  opacity: 1 !important;
  cursor: default !important;
}

.reaction-picker {
  position: absolute;
  top: -2rem;
  right: -0.5rem; /* ‚úÖ Âêπ„ÅçÂá∫„ÅóÂè≥Á´Ø„ÇíÂü∫Ê∫ñ„Å´ÂÜÖÂÅ¥„Å´ÈÖçÁΩÆ */
  display: flex;
  gap: 0.4rem;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 1.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  padding: 0.4rem 0.6rem;
  font-size: 1.3rem;
  z-index: 10;
  white-space: nowrap;
}


.emoji-list {
  display: flex;
  gap: 0.4rem;
}

.copy-icon {
  margin-left: auto;
  cursor: pointer;
}

.reaction-display {
  position: absolute;
  top: -0.6rem;
  right: -0.6rem;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(4px);
  border-radius: 1rem;
  padding: 0.2rem 0.4rem;
  font-size: 1rem;
  display: flex;
  gap: 0.3rem;
  pointer-events: none;
  z-index: 5;
}
.message-wrapper {
  position: relative;
  display: inline-block;

  /* üõ°Ô∏è wrapperÂÅ¥„Å´„ÇÇÈò≤Ê≠¢„ÇíËøΩÂä† */
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

/* ‚ú® „É™„Ç¢„ÇØ„Ç∑„Éß„É≥Ôºö‰∏ä„Å´‰∏ÄÊôÇË°®Á§∫Ôºà„Éî„ÉÉ„Ç´„ÉºË°®Á§∫ÊôÇ„Å™„Å©„Å´‰Ωø„ÅÜÔºâ */
.reaction-display.over {
  position: absolute;
  top: -0.4rem;
  right: 1.7rem; /* ‚úÖ „Åì„Åì„Çí„Éû„Ç§„Éä„Çπ„Åã„Çâ„Éó„É©„Çπ„Å∏ */
  background: transparent;
  backdrop-filter: none;
  border-radius: 0;
  padding: 0;
  font-size: 1rem;
  display: flex;
  gap: 0.3rem;
  pointer-events: none;
  z-index: 10;
  box-shadow: none;
}

/* ‚úÖ ÈÄöÂ∏∏„ÅÆ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫ */
.reaction-display {
  position: absolute;
  z-index: 5;
  pointer-events: none;
  white-space: nowrap;
  background: transparent;
  backdrop-filter: none;
  border-radius: 0;
  padding: 0;
  font-size: 1rem;
}

/* üéØ Áõ∏Êâã„Åã„Çâ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Áî®ÔºàÂ∑¶‰∏äÔºâ */
.left-corner {
  left: -0.6rem;
  transform: none;
}

/* üéØ Ëá™ÂàÜ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Áî®ÔºàÂè≥‰∏äÔºâ */
.right-corner {
  top: -0.6rem;
  right: 0.1rem; /* ‚Üê ÊôÇË®à„Å´„ÅØË¢´„Çâ„Åö„ÄÅÂêπ„ÅçÂá∫„ÅóÂè≥‰∏ä„Å´„Éî„ÉÉ„Çø„É™Èáç„Å™„Çã */
  transform: none;
}




/* üéØ ÂêÑ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÁµµÊñáÂ≠óÔºöË£ÖÈ£æ„ÇíÂÆåÂÖ®Èô§Âéª */
.reaction-display span {
  display: inline-block;
  font-size: 1.1rem;
  line-height: 1;
  padding: 0;
  background: none;
  box-shadow: none;
  border-radius: 0;
  color: inherit;
}

.copy-button {
  position: absolute;
  top: -0.5rem;
  right: -1.2rem;
  background: rgba(255, 255, 255, 0.95);
  border: none;
  border-radius: 9999px;
  font-size: 1rem;
  padding: 0.2rem 0.4rem;
  box-shadow: 0 1px 4px rgba(0,0,0,0.2);
  z-index: 10;
}

.message-placeholder {
  width: 120px;
  height: 120px;
  background-color: #eee;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  cursor: pointer;
}

.image-wrapper {
  width: 220px;
  height: 220px;
  border-radius: 12px;
  overflow: hidden;
  background-color: #eee;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.message-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 12px;
}

/* ‰∏ÄÊôÇÁöÑ„Å™ÁîªÂÉèÔºà‰æãÔºö„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠Ôºâ */
.message-image.temp {
  opacity: 0.4;
  filter: blur(1px);
}

.message-placeholder {
  width: 100%;
  height: 100%;
  background-color: #eee;
  border-radius: 10px;
  font-size: 2rem;
  color: #999;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

.message a {
  color: #3366cc;
  text-decoration: underline;
  word-break: break-word;
}

.emoji-only {
  font-size: 3.5rem;
  line-height: 1;
  display: inline-block;
  background: transparent;
  box-shadow: none;
  padding: 0;
  margin: 0.1em 0;
  animation: emojiWobble 3s ease-in-out infinite alternate; /* ‚Üê 3s„Å´Â§âÊõ¥ */
  vertical-align: middle;
}

.emoji-only.mine {
  align-self: flex-end;
  text-align: right;
}

/* „ÇÜ„Å£„Åè„Çä„ÇÜ„Çâ„ÇÜ„Çâ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
@keyframes emojiWobble {
  0%   { transform: translateY(0px) rotate(0deg); }
  50%  { transform: translateY(-2px) rotate(-4deg); }
  100% { transform: translateY(0px) rotate(4deg); }
}

</style>
